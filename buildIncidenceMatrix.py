
import os
import numpy as np
from functools import wraps
import time
import matplotlib.pyplot as plt


PATH_DIRECTORY_TEST = ".\\testAnalyze"
PATH_DIRECTORY_OUTPUT = ".\\outputMatrix"
NAME_FILE_MATRIX_INCIDENCE = "incidenceMatrix"
NAME_FILE_SOLUTION = "xSolutionVector"
NAME_FILE_TIME = "times"
ACTIVE_DRAW_GRAPH = 0

def timeit(func):
    @wraps(func)
    def timeit_wrapper(*args, **kwargs):
        w = open(os.path.join(PATH_DIRECTORY_OUTPUT,f"{NAME_FILE_TIME}.txt"), "a")
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()
        total_time = end_time - start_time
        #print(f'Function {func.__name__}{args} {kwargs} Took {total_time:.4f} seconds')
        w.write(f"Function {func.__name__} Took {total_time:.4f} seconds\n")
        return result
    return timeit_wrapper

class Arch():
    index:int
    source:int
    destination:int
    maxCapacity:int
    cost:int
    def __str__(self) -> str:
        return f"a Source: {self.source}, Destination: {self.destination}, MaxCapacity: {self.maxCapacity}, Cost: {self.cost}" 
class Node():
    name:str
    deficit:int
    def __str__(self) -> str:
        return f"n Name: {self.name}, Deficit: {self.deficit}"
class IncidenceMatrix():
    m:np.array = np.array([])
    arches:dict = {} #the key is the source-destination and the value is the Arch object 
    nodes:list = []
    nRow:int
    nColl:int
    archParallel:int
    maxCost:int
    minCost:int
    maxCapacity:int
    minCapacity:int
    avgDeficit:int
    totDeficit:int
    seed:int
    generator:str

    def __str__(self) -> str:
        rMatrixStr = str(self.m)
        rStr = f'''generated by the {self.generator} generator \n
                average parallel = {self.archParallel} \n
                max/min cost = {self.maxCost}/{self.minCost} \n
                max/min capacity = {self.maxCapacity}/{self.minCapacity} \n
                average deficit = {self.avgDeficit} \n
                total deficit = {self.totDeficit} \n
                seed = {self.seed} \n'''
        rStr = rStr + rMatrixStr
        return rStr

# this class rapresents a list of istances of problem MCF for CG algorithm
# A*x = vectorOfB
class istanceMCF_CG:
    A:np.matrix #E*D^-1*Et
    EMatrix:np.matrix
    diagonalMatrix:np.matrix
    vectorOfB:np.array

class listOfPointsXY:
    listX:list[int]
    listY:list[int]
class PointXY:
    x:int
    y:int
# This function created a dir with a name
def creationDir(nameDir:str):
    if(not(os.path.isdir(nameDir))):
        os.makedirs(nameDir)
# This function builds a diagonal positive Matrix and returns it
# @param nRow: the number of rows
# @param nColl: the number of collums
def diagonalM(nRow:int, nColl:int) -> np.matrix:
    gen:np.random = np.random
    m:np.array;
    s:np.array = np.array([])

    for i in range(nRow):
        for j in range(nColl):    
            if(j == i):
                s = np.append(s,[gen.randint(1,10)])
            else:
                s = np.append(s,[0])
            if(j == nColl-1):
                if(i == 0):
                    m = s
                else :
                    m = np.vstack((m,s))
                s = np.array([])
    return np.matrix(m)

# This fuction take 2 params:
# - A list of Nodes 
# - A dictionary of Arches
def buildIncidenceMatrix(nodes:list,arches:dict):
    cIndex:int = 0
    arrMatrix:list = []
    rMatrix:IncidenceMatrix = IncidenceMatrix()
    print(f"numFile: {len(os.listdir(PATH_DIRECTORY_TEST))}") 
    for path in os.listdir(PATH_DIRECTORY_TEST):
        
        i:int = 0
        creationDir(PATH_DIRECTORY_OUTPUT)
        w = open(os.path.join(PATH_DIRECTORY_OUTPUT,f"{NAME_FILE_MATRIX_INCIDENCE}{i}.txt"), "w")
        r = open(os.path.join(PATH_DIRECTORY_TEST, path), "r")
        for line in r:
            match line[0]:
                case "c":
                    if("generated" in line):
                        pieces = line.split(" ")
                        rMatrix.generator = f"{pieces[len(pieces) - 2]}"
                    elif(" parallel " in line):
                        rMatrix.archParallel = int(line[len(line)-2])
                    elif(" cost " in line):
                        rMatrix.maxCost = int(line[len(line) - 4])
                        rMatrix.minCost = int(line[len(line) - 2])
                    elif(" capacity " in line):
                        rMatrix.maxCapacity = int(line[len(line) - 4])
                        rMatrix.minCapacity = int(line[len(line) - 2])
                    elif("average deficit " in line):
                        rMatrix.avgDeficit = int(line[len(line)-2])
                    elif("total deficit " in line):
                        rMatrix.totDeficit = int(line[len(line)-2])
                    elif(" seed " in line):
                        rMatrix.seed = int(line[len(line)-2])        
                # in line with p there is number of nodes and arches
                # but it has to verify
                case "p":
                    arrValue = line.split(" ")
                    rMatrix.nColl = int(arrValue[3])
                    rMatrix.nRow = int(arrValue[2])
                    rMatrix.m = np.zeros((rMatrix.nRow, rMatrix.nColl))
                case "a":
                    values = line.split()
                    arch:Arch = Arch()
                    arch.index = cIndex
                    cIndex = cIndex + 1
                    arch.source = int(values[1])
                    arch.destination = int(values[2])
                    
                    rMatrix.m[arch.source - 1][arch.index] = 1
                    rMatrix.m[arch.destination - 1][arch.index] = -1

                    arch.maxCapacity = int(values[4])
                    arch.cost = int(values[5])
                    arches[f'{arch.source}-{arch.destination}'] = arch
                case "n":
                    values = line.split()
                    node:Node = Node()
                    node.name = values[1]
                    node.deficit = int(values[2])
                    nodes.append(node)
        w.write(str(rMatrix))
        i = i +1
        # print("++++++++++++++++++")
        # [print(nodes[i]) for i in range(len(nodes))]
        # print("++++++++++++++++++++++")
        # [print(arches[i]) for i in range(len(arches))]
        rMatrix.nodes.extend(nodes)
        rMatrix.arches.update(arches)
        arrMatrix.append(rMatrix)
        w.close()
        r.close()
    return arrMatrix 

def buildArrayDeficit(listNodes:list) -> np.array:
    c = np.array([])
    for node in listNodes:
       c = np.append(c,[[node.deficit]])
    return c
def buildArrayCosts(dictArches:dict) -> np.array:
    b = np.array([])
    for key in dictArches.keys():
       b = np.append(b,[[dictArches[key].cost]])
    return b
# this function has to calculate the condition Ex = c
@timeit
def testConservationRule(incidenceMatrix:np.matrix,c:np.array,x:np.array = np.array([])):
    # det = np.linalg.det(incidenceMatrix)
    # print("det: {det}")
    matrixInv = incidenceMatrix.getI()
    
    print(matrixInv)
    x = np.matmul(matrixInv,np.transpose(c))
    print(f"\nDIRECT TEST x: {x}\n")

def createInstanceMCF_CG(eMatrixs:list) -> list[istanceMCF_CG]:
    istancesProblem:list = []
    for i in range(len(eMatrixs)):
        istanceMCF = istanceMCF_CG()
        c = buildArrayDeficit(eMatrixs[i].nodes)
        b = buildArrayCosts(eMatrixs[i].arches)
        istanceMCF.matrix = np.matrix(eMatrixs[i].m)
        numOfArches:int = istanceMCF.matrix.shape[1]
        # this matrix is m*m that is arches number  
        istanceMCF.diagonalMatrix = diagonalM(numOfArches,numOfArches)
        #E*D^-1*Et
        istanceMCF.A = np.matmul(np.matmul(istanceMCF.matrix,istanceMCF.diagonalMatrix.getI()),istanceMCF.matrix.getT())
        #It's all values w
        istanceMCF.vectorOfb = np.matmul(np.matmul(istanceMCF.matrix,istanceMCF.diagonalMatrix.getI()),b) - c
        istancesProblem.append(istanceMCF)
    return istancesProblem
    
# algorithm
# A is a matrix of system Ax = b
# b is a vector of system Ax = b
# x0 is the starting point
# n is the number of iterations of the algorithm
@timeit
def conjugateGradient(A:np.matrix, b:np.array, x:np.array, n:int) ->listOfPointsXY:
    w = open(os.path.join(PATH_DIRECTORY_OUTPUT,f"{NAME_FILE_SOLUTION}.txt"), "w")
    xGraph:list[int] = [] # number of iteration
    yGraph:list[int] = [] # difference between real b and artificial b
    listPoints:listOfPointsXY = listOfPointsXY()
    listPoints.listX = []
    listPoints.listY = []
    if(A.shape[1] != b.shape[0]):
        print('\n-------------------------------------')
        print("ERROR on dimension")
        print(f"dim A: {A.shape}, dim b: {b.shape}")
        print('-------------------------------------\n')
        return
    r:np.array = np.copy(b)# - A*x0 # residual Ax - b
    d = np.copy(r) # directions vector
    alpha = np.array([])
    beta = np.array([])
    # print(f"r: {r}")
    # print(f"A.dimensions {A.shape}")
    proveB:int
    for j in range(n):
        numAlpha = np.matmul(np.transpose(r),r)
        denAlpha = np.matmul(np.transpose(d),np.matmul(A,d))

        alpha = np.append(alpha,numAlpha/denAlpha)
        #print(f"alpha{j}:{alpha[j]}")
        x = x + alpha[j]*d
        xGraph.append(j)
        proveB =  np.matmul(A,x)
        proveBNorm = np.linalg.norm(b - proveB)/np.linalg.norm(proveB) 
        yGraph.append(proveBNorm)
        r = r - alpha[j]*(A*d)
        beta = np.append(beta,np.matmul(np.transpose(r),r)/numAlpha)
        d = r + beta[j]*d
    # print(f"x : {xGraph}")
    # print(f"y : {yGraph}")
    listPoints.listX.extend(xGraph)
    listPoints.listY.extend(yGraph)
    w.write(f"A*x = b")
    w.write(f"Shape of A:{A.shape}\n A:\n{A}\n")
    w.write(f"Shape of x:{x.shape}\n CG x:\n{x}\n")
    w.write(f"Shape of x:{b.shape}\n CG b:\n{b}\n")
    w.write(f"Shape of proveB:{proveB.shape}\n CG proveB:\n{proveB}\n")
    w.write(f"CG proveBNorm:{proveBNorm}\n")
    
    w.close()
    return listPoints
 
def main():
    print("MAIN")
    eMatrixs:list = buildIncidenceMatrix([],{})
    lInstancesProblemCG:list[istanceMCF_CG] = createInstanceMCF_CG(eMatrixs=eMatrixs)
    #for i in range(10):
    listofListPoint = []
    for i in range(10):
        for instance in lInstancesProblemCG:
            listofListPoint.append(
                conjugateGradient(
                    A=instance.A,
                    b=np.transpose(instance.vectorOfb),
                    x=np.zeros((instance.A.shape[0],1)),
                    n=100
                )
            ) 
            plt.plot(listofListPoint[i].listX,listofListPoint[i].listY, label = f'iteration{i}')
    
    if(ACTIVE_DRAW_GRAPH == 1):
        plt.xlabel('X-axis')
        plt.ylabel('Y-axis')
        plt.title("A simple line graph")
        # show a legend on the plot
        plt.legend()
        plt.show()
    # c = buildArrayDeficit(eMatrix[0].nodes)
    # b = buildArrayCosts(eMatrix[0].arches)
    # # first param is the matrix/array
    # # second param is the position of new column
    # # third param is new value
    # # fourth is the number of axis
    # #m = insert(m, [1], [[1],[2],[3]], 1)
    # #matrix:IncidenceMatrix = IncidenceMatrix(3,4);

    # # [print(str(arr[0].nodes[i])) for i in range(len(arr[0].nodes))]
    # # for x in arr[0].arches:
    # #     print(x)
    # #     print (str(arr[0].arches[x]))
    # # print(len(eMatrix))
    # matrix = np.matrix(eMatrix[0].m)
    # diagonalMatrix = diagonalM(matrix.shape[1],matrix.shape[1])
    # #E*D^-1*Et
    # A = np.matmul(np.matmul(matrix,diagonalMatrix.getI()),matrix.getT())
    # #print(f"shape matrix E: {matrix.shape}, {diagonalMatrix.shape}")
    # #It's all values w
    # vectorOfb = np.matmul(np.matmul(matrix,diagonalMatrix.getI()),b) - c
    # # testConservationRule(matrix,c)
    # #print(f"shape[0]: {matrix.shape[0]}")    
    # print(diagonal)
    # print(diagonal.shape)        

main()